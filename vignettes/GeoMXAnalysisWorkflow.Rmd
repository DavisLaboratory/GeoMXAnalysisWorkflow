---
title: "Analysing Nanostring's GeoMX transcriptomics data using standR, limma and vissE"
author:
  - name: Ning Liu
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - Department of Medical Biology, University of Melbourne, Parkville, VIC 3010, Australia
    email: liu.n@wehi.edu.au
  - name: Chin Wee Tan
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - Department of Medical Biology, University of Melbourne, Parkville, VIC 3010, Australia
    email: cwtan@wehi.edu.au
  - name: Melissa J Davis
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - Department of Medical Biology, University of Melbourne, Parkville, VIC 3010, Australia
      - Department of Biochemistry and Molecular Biology, Faculty of Medicine, Dentistry and Health Sciences, University of Melbourne, Parkville, VIC, 3010, Australia
    email: davis.m@wehi.edu.au
date: "`r format(Sys.time(), '%b %Y')`"
output:
  prettydoc::html_pretty:
    theme: cayman
    toc: yes
    toc_depth: 2
    number_sections: yes
    fig_caption: yes
    df_print: paged
nocite: | 
  @R-ggplot2, @R-knitr, @R-BiocWorkflowTools, @R-rmarkdown, @R-prettydoc
bibliography: [packages.bib]
vignette: >
  %\VignetteIndexEntry{Analysing Nanostring's GeoMX transcriptomics data using standR, limma and vissE.}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
keywords: DifferentialExpression, Normalization, QualityControl, Spatial, Transcriptomics
abstract: >
  Abstract
---

<p>

**R version**: `r R.version.string` <br /> **Bioconductor version**: `r BiocManager::version()` 

</p>

```{r setup, include=FALSE}
#set knitr chunk options
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

#load packages to avoid startup messages later in the code
library(standR)
library(SpatialExperiment)
library(limma)
library(edgeR)
library(tidyverse)
library(vissE)
library(GSEABase)
library(msigdb)
library(ggalluvial)
library(ExperimentHub)

#automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'knitr', 'rmarkdown', 'prettydoc'
), 'packages.bib')
```


# Background and introduction

## Nanostring GeoMX data

Nanostring's GeoMx DSP data comes from the GeoMx DSP workflow which integrates standard pathology and molecular profiling to obtain robust and reproducible spatial multiomics data. DSP data typically comes from whole tissue sections, FFPE or fresh frozen samples. These can be imaged and stained for RNA or protein using which specific tissue compartments or cell types to be profiled based on the biology can be selected. These selected `regions` or `areas` of interests will have their count expression levels quantified using either the nCounter Analysis System or an Illumina Sequencer.

GeoMx RNA assays allows quantitative and spatial measurements of transcripts (up to the whole transcriptome) from single sections of FFPE or fixed fresh frozen tissues. Typical gene panels utilised include the Cancer transcriptome Atlas (CTA, ~1800 genes) and Whole Transcriptome Atlas (WTA, ~ 18000 genes). 

Count data are generated from the DSP pipeline and technical pre-processed using the GeoMx Data Analysis Suite (DSPDA). This includes the removal of low performing probes and calculation of a typical QC metrics called LOQ using the negative probes. Data normalization are typically conducted based on recommendations from Nanostring by the technologist/technicians with a suggested Q3 normalized data output. 

**Note: Q3-normalised data is not recommended for any bioinformatics workflow or pipeline. Rather, the technical probe corrected counts (probeQC, which accounts for any technical machine systematic errors during the DSP run) is recommended.**

![flowchart](workflow.jpg)


## Analysis of spatial GeoMX datasets

A typical bioinformatics analysis of a GeoMX DSP dataset often starts with a count table (from sequencing reads of genes for each region of interest (ROI)), and ends with either identifying differential expressed genes or performing gene signature/gene-set scoring pathway/enrichment analyses in various conditions or experimental designs. Nevertheless, before performing any differential expression (DE) analysis or other downstream analyses that are based on the gene counts, proper quality control(QC) and normalisation of the data is essential and if not done properly, will greatly impact the correctness and validity of the DE and corresponding downstream analysis' results. 
We therefore developed a bioconductor package called `standR` (**S**patial **t**ranscriptomics **a**nalyzes a**n**d **d**ecoding in **R**) to assist the QC, normalisation and batch correction of the GeoMX transcriptomics data. 

There are three major advantages of using the `standR` package to analyse the GeoMX DSP datasets:

1. The package uses the `SpatialExperiment` infrastructure to analyse the data, this infrastructure is a lineage of the `SummarisedExperiment` family, which is highly recommended in the bioconductor community. It is compatible and transferable with many other well developed packages in the RNA-seq analysis world, such as `scater`, `scran`, `edgeR` and `limma`.

2. The package features a comprehensive route for quality control, and provides various visualisation functions to help in the assessment of the various quality control metrics.

3. Batch effect is a common feature in transcriptomic dataset, especially in GeoMX DSP data due to the way the slides are typically utilised due to experimental constrains/designs. The package currently provides three batch correction methods that will remove the unwanted batch effect and provides statistics for assessing the correction process and outcomes.

In this workshop, we will firstly use `standR` to process and analyse a published GeoMX WTA dataset using the recommended workflow. This will demonstrate our recommended workflow for processing and analysing GeoMX transcriptomics datasets. Secondly, we will perform  DE analysis of the processed data using the `limma-voom` pipeline, followed by a gene-set enrichment analysis using `fry` and subsequent visualisation of the higher order results using the R package `vissE`.


# Using standR to process and analyse GeoMX transcriptomics data

## Load data

The data we are using in this workshop is a published GeoMX whole transcriptome atlas (WTA) dataset of diabetic kidney disease (DKD) that was made available by Nanostring (http://nanostring-public-share.s3-website-us-west-2.amazonaws.com/GeoScriptHub/KidneyDataset/).

This dataset includes data on **seven slides**, which includes **4 DKD and 3 healthy** slides. The ROI selection strategy employed is a regional based approach focused primarily on two distinct structures found in the kidney, namely: **tubules or glomeruli**.   

*Glomeruli* ROIs were identified and curated by a pathologist as either **relatively healthy or diseased** regardless of the tissue type (DKD or healthy).  
*Tubule* ROIs were segmented into **distal (PanCK positive) and proximal (PanCK negative)** tubules. Distal and proximal tubules are distinct in terms of their differing functions in the kidney.

This GeoMX DSP data can be retrieved by querying the `ExperimentHub` repository. The query below searches for all objects in the hub associated with the search term "standR". 

```{r}
library(ExperimentHub)

eh <- ExperimentHub()
query(eh, "standR")

```

The three files that are associated with the DKD GeoMX data in the `standR` package can then be retrieved by specifying their IDs.
The respective objects can then be retrieved using the accession IDs ("EH7364" for counts,"EH7365" for sample annotation,"EH7366" for gene annotations) 

```{r}
countFile <- eh[["EH7364"]]
sampleAnnoFile <- eh[["EH7365"]]
featureAnnoFile <- eh[["EH7366"]]
```

We can have a first look at the format of the three files, which are the typical files made available by NanoString.

The `countFile` is a tab-delimited file, it contains the count table (features by samples) we generally see in transcriptomics analysis. By default as provided by the Nanostring, it is required to have the gene name column with the column name of "TargetName".

```{r}
read.delim(countFile, nrows = 5)[,1:3]
```


The `sampleAnnoFile` is a tab-delimited file, containing all the annotation (metadata) for the samples. By default as provided by the Nanostring, it is required to include the sample name column with the column name of "SegmentDisplayName".

```{r}
read.delim(sampleAnnoFile, nrows = 5)[,1:5]
```


The `featureAnnoFile` is a tab-delimited file, containing all the annotation (metadata) of the genes in the dataset. By default as provided by the Nanostring, it is required to include the gene name column with the column name of "TargetName".

```{r}
read.delim(featureAnnoFile, nrows = 5)
```


As  described in the introduction, there are many advantages to use a mature infrastructure throughout the analysis, such as compatibility with other tools.

Therefore, the first step in the `standR` package workflow is to construct a `SpatialExperiment` object that includes all the information available in the data. Here we can use the function `readGeoMX` to do so. For more information about the `SpatialExperiment` infrastructure, see [here](http://www.bioconductor.org/packages/release/bioc/html/SpatialExperiment.html).

**Note 1: by default, the `readGeoMx` function will look for the gene name column in both the `countFile` and `featureAnnoFile` with the column name of "TargetName", and the sample name column in the `sampleAnnoFile` with the column name of "SegmentDisplayName", these column names are given by the Nanostring in the default settings, if your data have been modified, you can indicate the corresponding column names by specifying the parameter "colnames.as.rownames" in the `readGeoMx` function when loading the data.**

**Note 2: if you plan to use `readGeoMx` to construct the `SpatialExperiment` object with your own data, make sure that the files you use as inputs are tab-delimited files.**

```{r message=FALSE}
library(standR)

spe <- readGeoMx(countFile, sampleAnnoFile, featureAnnoFile = featureAnnoFile)
```

Check the basic information about the dataset by entering the object name directly. 
We see that the data has measurements for approximately 18503 genes and 231 ROIs.

```{r}
spe
```

Both count-level data and logCPM measurements are stored in the `spatialExperiment` object. Specifically, the raw count data is stored in the `counts` assay slot, while the log-CPM (count per million) of the data is calculated by default with the `readGeoMX` function and stored in the `logcounts` assay of the object.


```{r}
assayNames(spe)
```

We can have a look at the count table by using the `assay` function and specify the table name.

```{r}
assay(spe, "counts")[1:5,1:5]
```


```{r}
assay(spe, "logcounts")[1:5,1:5]
```

Sample metadata is stored in the `colData` of the object.

```{r}
colData(spe)[1:5,1:5]
```

Gene metadata are stored in the `rowData` of the object.

```{r}
rowData(spe)[1:5,]
```

The `readGeoMX` function has other parameters such as `hasNegProbe` and `NegProbeName` that are designed to deal with negative probes in the data. **Then breifly talking about negprobes in both WTA and CTA.**
By default, the `readGeoMx` function will remove the negative probe, the entry with name "NegProbe-WTX", in the count table and put it in the metadata of the object. User can turn this off by specifying `hasNegProbe = FALSE` in the function, just make sure there are no duplicate gene names in the "TargetName" column.

```{r}
metadata(spe)$NegProbes[,1:5]
```





## Import from DGEList object

Alternatively, `standR` provides a function to generate a spatial experiment object from a DGEList object, which would be useful for users who used `edgeR` package and have existing analyses and implementations using DGEList objects to port across to the standR workflow.

```{r}
dge <- edgeR::SE2DGEList(spe)

spe2 <- readGeoMxFromDGE(dge)

spe2
```




## Quality control

The recommended quality control (QC) checks for the GeoMX transcriptome data consist of three major steps:

1. **Inspection of the sample metadata**: sample metadata can be view in  
tabular-like format using the `colData` function, however here we aim to 
visualise the relations across the various sample information, such as which slide 
did the ROIs came from, which are the control groups and treatment groups, what 
are the pre-defined tissue types etc. By doing this, we will have an overview of how   
the experiment was designed, the potential questions of interest, are they clear 
batch effects to look out for, and the comparisons of interest that can be established. 

2. **Gene level QC**: At the gene level, by default we aim at removing genes that 
are not expressed in more than 90% of the ROIs, and identifying any ROIs with 
very few genes being expressed.  
This is similar to the process used in `edgeR::filterByExpr`, as genes with consistently 
low counts are unlikely be identified as significant genes. By keeping only the genes with 
sufficiently large counts in the analysis, we can increase the statistical power while 
reducing multiple testing burden.

3. **ROI level QC**: At the ROI level, we aim to identify the low-quality ROIs that have 
small library size (i.e. total feature count) and low cell count. these low-quality ROIs, 
if not removed would show up as isolated clusters in the dimension reduction plots (PCA/UMAPs)
and thereby affect the comparisons conducted during DE analyses. 


### Sample level QC

To visualise sample metadata, we can use the `plotSampleInfo` function. 
In this dataset, the following key features are of interest for which we would like to look at:
slides ("SlideName"), diseases status ("disease_status"), tissue regions ("region"), and the  
different cancer subtypes ("pathology"). These can be queries by listing them in the function. 

```{r}
plotSampleInfo(spe, column2plot = c("SlideName","disease_status","region","SegmentLabel","pathology"))
```


Based on the known sample information, we know that all the *glomerulus* ROIs are classified 
as either abnormal or healthy, and *tubule* are classified as PanCK negative("neg") or positive ("PanCK"). 

We therefore merge the region and segment/pathology related annotations to avoid collinearity, which 
can cause problems when dealing with batch correction. Specifically:  
For *glomerulus*, "region" will concatenate with "pathology".    
For *tubule*, "region" will concatenate with "segmentLabel". 


```{r}
colData(spe)$regions <- paste0(colData(spe)$region,"_",colData(spe)$SegmentLabel) %>%
  gsub("_Geometric Segment","",.) %>%
  paste0("_",colData(spe)$pathology) %>%
  gsub("_NA","",.)


colData(spe)$regions %>% table()
```


Re-plot the amended sample annotation to check that the changes have been made.   
It is now clearer and more straightforward in terms of the comparisons we can establish and work with.


```{r}
plotSampleInfo(spe, column2plot = c("SlideName","disease_status","regions"))
```



### Gene level QC

Now we check on the gene level data. Using the `addPerROIQC` function, we can add  
key statistics to the `colData` of the object. For the purpose of this exercise,  
we will set the argument `rm_genes` to TRUE, and keeping the default settings of  
`min_count = 5` and `sample_fraction = 0.9`. We first calculate the expression  
threshold using the logCPM data (to account for library size variations), we then  
filter out the genes with low-expression values that's below the set threshold in  
more than 90% of the ROIs. 

```{r}
spe <- addPerROIQC(spe, rm_genes = TRUE)
```

Looking at the object again, we can see that 121 genes were removed.

The count matrix of the genes that were removed will be stored in the `metadata`  
of the object with prefix *genes_rm*, alongside the calculated expression  
threshold (*lcpm_threshold*).

```{r}
dim(spe)

metadata(spe) |> names()
```


Using the `plotGeneQC` function, we can then assess the logCPM expressions of the  
genes that were removed across the samples. The function also plots the histogram  
/distribution of the proportion of non-expressed genes in all the ROIs (as a  
percentage). By default, the top 9 genes are plotted here (ordered by the mean 
expression). Users can customise the number of genes plotted using the parameter 
`top_n`.

Moreover, users can order the samples (using parameter `ordannots`) or color/shape  
the dots by specific annotation to better compare and assess for specific biological 
or experimental factors which are influencing how these genes were expressed across 
the samples (e.g. gene may be higly expression in particular tissue types or under 
particular treatment conditions. This genes are to be access or curated by domain 
experts to ascertain or determine if any of these genes are of biological/experimental 
significance. This provides a potential warning to whether the experiments have worked 
as per intended. 

```{r}
plotGeneQC(spe, ordannots = "regions", col = regions, point_size = 2)
```



### ROI level QC

After clecking the genes, we can now look at the ROI level data.
Using the `plotROIQC` function, we can visualise QC statistics at the ROI level. 
By default, the library size and cell count (AOINucleiCount) will be computed.

In the ROI level QC, we first aim to identify (if any) ROI(s) that have 
relatively low library size and low cell count because they are considered as 
low quality samples due to insufficient sequencing depth or the lack of RNA in 
the selected region. Frequency histograms are also provided for both library size
and nuclei count to assist with assessing any abnormal distributions of samples
in the data.

In this case, we assess the distribution plot for library size against the nuclei 
count. Looking at the scatter plot, we expect the library sizes to be mostly 
positively correlated with the cell count (i.e. nuclei count). It is not unexpected 
for there to be some ROIs having relatively low library size and having a reasonable 
number of cells (nuclei count). In this dataset, we see this library size vs cell 
count relationship is relatively smooth with no aberrations observed (e.g. spikes at 
the lower ranges)

To remove/filter low quality samples, we define a filtering threshold near the lower 
end of the library size range, in this case at 50,000. By stratifying (color) the 
points based on their slide names, we not that the ROIs below the threshold are all 
from slide *disease1B* (pale orange). This might suggest potential of some technical 
errors associated with slide *disease1B*.

```{r}
plotROIQC(spe, y_threshold = 50000, color = SlideName)
```

In this experiment, based on the above plot, the library size threshold of 50,000 
looks to be a reasonable cutoff. As such we subset the spatial experiment object based  
on the library size using this threshold in `colData`.

```{r}
qc <- colData(spe)$lib_size > 50000
spe <- spe[, qc]
```

**Note: The same workflow and logic can also be applied to the nuclei count. We will also check the gene detection rate to assess the quality of the dataset.**

The function `plotROIQC` is looking at nuclei count and library size of each ROI by default, user can change the x or y axis to any other statics they want to QC by specifying the parameter `x_axis` or `y_axis`. For example, the statistics limit of quantification (LOQ) is summarised by the Nanostring process pipeline and it's provided in most/all of the GeoMX DSP dataset. This metrics is calculated by on the distribution of the negative probes, and it's suggested by Nanostring that LOQ can be useful when there are large segments (i.e. big ROI or high cell count samples), and a minimum LOQ of 2 is recommended.

```{r}
plotROIQC(spe,  y_axis = "LOQ", y_lab = "LOQ", x_axis = "lib_size", x_lab = "Library size",  y_threshold = 2, col = SlideName)
```



### Relative log expression distribution

After filtering, we will use function `plotRLExpr` to visualise the relative log 
expression (RLE) of the data to identify any technical variation that may be 
present in the dataset. We looks at the relative distance between the median of 
the RLE for each ROI (the dot in the boxplot) to zero. 

By default, we plot the RLE of the raw count, where we expect to see majority of 
the variation to be contributed by differences in library size.

```{r fig.width=10}
plotRLExpr(spe)
```

By using `assay = 2` to run RLE on the logCPM data, we can see that most of the 
technical variations due to library size differences are removed.  

We can follow up by sorting the data based on the different sample metadata annotations 
by specifying the `ordannots` parameter. This can be visualised either with color or 
shape mapping parameters (based on similar approaches for plotting in `ggplot`), 
enabling quick assessment of the possible factors that's contributing to the 
observed technical variation(s).

In this case, we stratify by *slideName* using different colors which clearly show 
substantial variations between the slides as well as to a lesser extent within each slide. 

```{r fig.width=10}
plotRLExpr(spe, ordannots = "SlideName", assay = 2, color = SlideName)
```

We can also try out other factors (e.g. regions ) to see how they influence the expression. 

```{r fig.width=10}
plotRLExpr(spe, ordannots = "regions", assay = 2, color = regions)
```

### Dimension reduction


#### PCA


We can also look at the data by breaking it down into the lower dimensions. 

Using the `drawPCA` function, we can perform principal component analysis (PCA) 
on the data. The PCA can help visualise any potential systemic variations 
(both biological and technical) in the data and to identify the main factors 
contributing to the variations.

Here we stratify the points based on slide information (*SlideName* by color) 
and tissues regions (*regions* using shapes). It is clear that tissue regions
/types can be explained on PC1, particularly between *glomerulus* and 
*tubule*. ROIs group and clusters by the individual slide within each tissue 
structure. Note that the subtypes in the *tubule* ROIs are are clearly separated 
along PC2. This is not the case for the different subtypes of glomerulus 
(which groups together). 


```{r fig.height=8, fig.width=10}
drawPCA(spe, assay = 2, col = SlideName, shape = regions)
```

Diseased tissues and control tissues are mixed 
(disease slides and normal slides).


```{r fig.height=8, fig.width=10}
drawPCA(spe, assay = 2, col = disease_status, shape = regions)
```


The `standR` package also provide other functions to visualise the PCA, 
including the PCA scree plot, pair-dimension PCA plot and PCA bi-plot.

```{r}
plotScreePCA(spe, assay = 2, dims = 10)
```

```{r fig.height=12, fig.width=15}
plotPairPCA(spe, col = disease_status, 
            shape = regions, assay = 2, n_dimension = 4)
```

```{r fig.height=8, fig.width=10}
plotPCAbiplot(spe, n_loadings = 10, assay = 2, col = regions)
```



#### MDS

Another way to visualise the data is to look at the Multidimensional scaling (MDS) plots.
The function `plotMDS` provides the means to visualise the data in this way.

```{r fig.height=8, fig.width=10}
standR::plotMDS(spe, assay = 2, color = disease_status, shape = regions)
```


#### UMAP

Furthermore, since we're using `SpatialExperiment` as our infrastructure, we are 
able to incorporate or apply other widely used packages such as `scater`, which 
is commonly used in single cell data and spatial 10x genomics visium data analyses.
We also provide the function `plotDR` to visualise any dimension reduction results 
generated using `scater::run*`, such as UMAP, TSNE and NMF. This can be done by 
simply specifying the `dimred` parameter. 

Here we plot the UMAP of our data. Similar variations can be generated for other 
approaches like PCA and MDS as discussed earlier.


```{r fig.height=8, fig.width=10}
spe <- scater::runUMAP(spe)

plotDR(spe, dimred = "UMAP", col = regions)
```

## Normalization

If there are observed technical variations identified in the earlier QC steps, 
before proceeding with any analysis of the data, it is necessary to appropriately
perform normalisation of the data to rectify/minimise the identified variation.

The `standR` package offers normalization options including TMM, RPKM, 
TPM, CPM, upperquartile and sizefactor. Among these, RPKM and TPM require gene 
length information (add `genelength` column to the `rowData` of the object). 
For TMM, upperquartile and sizefactor, their normalized factor will be stored in 
their `metadata`.

Here we used TMM to normalize the data.  

```{r}
spe_tmm <- geomxNorm(spe, method = "TMM")
```


To assess how well the normalisation was able to remove unwanted variataions, 
we make use of RLE and PCA plot in conjunction with the factors of interest.

In this case, from the resulting RLE plot, most of the medians of RLE are close 
to zero, suggesting that most of the technical variation have been removed.


```{r fig.width=10}
plotRLExpr(spe_tmm, assay = 2, color = SlideName) + ggtitle("TMM")
```

However, from the PCA plots, the batch effect due to the different slides 
are still being observed, confounding the known biology of interest 
(which is between disease and normal).

```{r}
plotPairPCA(spe_tmm, assay = 2, color = disease_status, shape = regions)
```


## Batch correction

In the Nanostring's GeoMX DSP protocol, each slide is typically only able to  
fit a handful of tissue segments (Tissue microarrays/FFPE cores), it is common  
that DSP data are confounded by the batch effect introduced by the different  
slides. In order to establish appropriate comparisons between the ROIs in the 
downstream analyses, it is necessary to remove this batch effect from the data.

In the `standR` package, we provide two approaches for removing batch effects 
(RUV4 and Limma), more methods (e.g. RUVg) are included in the development version.

### Correction method : Remove Unwanted Variation 4 (RUV4)

Remove Unwanted Variation 4 (RUV4) is a method developed by Terry Speed and Johann Gagnon-Bartsch to use negative control genes to remove unwanted variations, 
see the published paper [here](https://academic.oup.com/biostatistics/article/13/3/539/248166).

To run batch correction using RUV4, a list of "negative control genes (NCGs)"
will be required.

`standR` provides a function `findNCGs` which identify the NCGs from the data. 
In this case, since the batch effect is mostly due to slide effects, we aim to 
identify NCGs across all the slides. As such, the `batch_name` parameter was set
to "SlideName", and the top 300 least variable genes (ranked by coefficient of variation) across different slides 
were identified as NCGs. These are stored in the object as "NCGs".


```{r}
spe <- findNCGs(spe, batch_name = "SlideName", top_n = 300)

metadata(spe) |> names()
```

Now we run RUV4 using the function `geomxBatchCorrection`. By default this function 
will use `RUV4` to normalize the data.  

For RUV4 correction, the function requires 3 addition parameters other than the input object: 

  * `factors`: the factor of interest, i.e. the biological variation to keep; 
  * `NCGs`: the list of negative control genes detected using the function `findNCGs`; 
  * `k`: the number of unwanted factors to use. Based on RUV's documentation, it is suggest 
  that to use the smallest k possible where the observed technical variation is no longer observed.  
  
Choosing the optimal k is one of the most important task when performing batch correction using RUV.
The best way to do so is to test out each k and assess the corresponding diagnostic plot (e.g. PCA).
The optimal k would be the smallest value that produces a separation of the main biology of interest 
of the experiment on a PCA plot.

So here we run through the paired PCA plots for k between 1 and 5. 

In this case, we create a combined factor of interest *biology* (concatenate *disease_status* and 
*regions* information) in the object. This factor will be specified in the `factors` parameter of 
the function.  


```{r fig.width=10, fig.height=9}
colData(spe)$biology <- paste0(colData(spe)$disease_status, "_", colData(spe)$regions)


for(i in seq(5)){
  spe_ruv <- geomxBatchCorrection(spe, factors = "biology", 
                   NCGs = metadata(spe)$NCGs, k = i)
  
  print(plotPairPCA(spe_ruv, assay = 2, n_dimension = 4, color = disease_status, shape = regions, title = paste0("k = ", i)))
  
}


```

After assessing the generated PCA plots, we choose k = 4 to be our best k.
From the resulting PCA, we can see that the disease status are reasonable  
separated within each region type.


```{r fig.width=10, fig.height=9}
spe_ruv <- geomxBatchCorrection(spe, factors = "biology", 
                   NCGs = metadata(spe)$NCGs, k = 4)


plotPairPCA(spe_ruv, assay = 2, color = disease_status, shape = regions, title = "RUV4, k = 4", n_dimension = 4)
```


```{r fig.width=10, fig.height=9}
plotPairPCA(spe_ruv, assay = 2, color = SlideName, title = "RUV4, k = 4", n_dimension = 4)
```



### Correction method: limma

The other available batch correction method is based on the `removeBatchEffect` 
function from the bioconductor package `limma`, more details of the method can see paper [here](https://academic.oup.com/nar/article/43/7/e47/2414268).

To use the limma batch correction, set the parameter `method` to "Limma", 
which uses the remove batch correction method from `limma` package. In this mode, 
the function requires 2 addition parameters other than the input object:  

  * `batch`: a vector that indicating the batch information for all samples; 
  * `design`: a design matrix generated from `model.matrix`, in the design matrix, 
  all biologically-relevant factors should be included.

In this case, the batch effect is based on the slides (SlideName) and factors of 
interest includes "disease_status" and "regions". 


```{r}

spe_lrb <- geomxBatchCorrection(spe,
                       batch = colData(spe)$SlideName, method = "Limma",
                       design = model.matrix(~disease_status + regions, 
                                             data = colData(spe))[,-1])
```


Once again, we use the respective QC plots like PCA to inspect and assess the
effectiveness of the applied batch correction process.

In this instance, using `limma::removeBatchEffect` approach seems to be over-corrected since we specifying the `batch` parameter as slide, however slide is confounded with the biology of interest.  


```{r fig.width=10, fig.height=9}
plotPairPCA(spe_lrb, assay = 2, color = disease_status, shape = regions, title = "Limma removeBatch", n_dimension = 4)
```




### Evaluation

#### Summary statistics

The typical approach to interrogating the effectiveness of batch correction 
process on the data uses dimension reduction plots like PCAs. Here we further 
suggest the use of summarized statistics to assess the effectiveness of batch 
correction. The 6 summarized statistics tested in this package includes:  

  * adjusted rand index.   
  * jaccard similarity coefficient.  
  * silhouette coefficient.  
  * Chi-squared coefficient.
  * Mirkin distance.  
  * Simple matching coefficient.  

This assessment can be conducted by using the `plotClusterEvalStats` function
provided in `standR`. 

Here we present the output for the summarised statistics for the two normalization 
methods in this workshop (i.e. RUV4 and Limma ) as well as the uncorrected data. 
Scores for each method will be presented as a barplot scores of the six summarized 
statistics (as above) under two sections (*biology* and *batch*). As a general rule, 
for the *biology* of interest defined in the batch correction process, a higher 
score is considered a good outcome. On the other hand, for the batch, a smaller 
score will be the preferred outcome.

We can see from the results that when it comes to stratifying based on biological 
factors (disease status and tissue regions) or quantifying the amount of clustering 
due to batch effects for this dataset, `RUV4` outperforms `limma` in most cases. 

```{r fig.width=10}
spe_list <- list(spe, spe_ruv, spe_lrb)

plotClusterEvalStats(spe_list = spe_list,
                     bio_feature_name = "regions",
                     batch_feature_name = "SlideName",
                     data_names = c("Raw","RUV4","Limma"))
```

#### RLE plots

In addition, we can visualize the outcomes using RLE plots of normalized count to 
determine which batch correction performs better for this dataset.

Plotting both the RLEs for RUV4-corrected and limma-corrected data, we can clearly 
see that RUV4-corrected data has in general a more-closer-to-zero median RLE when 
compared to that for the limma-corrected data. Therefore, for the downstream 
differential expression analysis, we would suggest using  RUV4 as the batch 
correction method for this specific dataset.

```{r fig.width=10}
plotRLExpr(spe_ruv, assay = 2, color = SlideName) + ggtitle("RUV4")
plotRLExpr(spe_lrb, assay = 2, color = SlideName) + ggtitle("Limma removeBatch")
```


# Differential expression analysis with limma-voom pipeline

For the downstream analyses such as differential expression analyses, standR does not provide specific functions. 

Instead, we recommend incorporating the workflow with well established pipelines, such as `edgeR`, `limma-voom` or `DESeq2`. These pipelines uses linear modelling which borrow information from all genes, making it more appropriate for complex dataset with various experimental factors. A simple T-test is definitely not recommended for performing DE analysis of GeoMX DSP data.

In this workshop, we'll demonstrate the DE analysis using the `limma-voom` pipeline.

We've shown in previous sections that for this dataset, using RUV4 with `k = 4` is the appropriate batch correction approach and is able to remove the batch effect and other undesired technical variations. To incorporate this correction into the linear model, we need to include the weight matrix generated from the function `geomxBatchCorrection` as covariates. The weight matrix can be found in the `colData`.


```{r}
colData(spe_ruv)[,seq(ncol(colData(spe_ruv))-3, ncol(colData(spe_ruv)))] |>
  head()
```

## Establishing a design matrix and contrast

To incorporate the `limma-voom` pipeline, we recommend using the `DGElist` infrastructure. Our `SpatialExperiment` can be easily transform into a `DGElist` object by using the `SE2DGEList` function from the `edgeR` package. For more information about `DGEList` see `?DGEList`.


```{r}
library(edgeR)
library(limma)

dge <- SE2DGEList(spe_ruv)

```


In our analysis, it is of interest to see which genes are differential expressed in different tissue regions within different status of the samples, a design matrix is therefore set up with both the disease status (DKD and normal) and tissue regions (glomerulus_healthy, glomerulus_abnormal, tubule_PanCK and tubule_neg) information. We added the W matrices resulted from the `RUV4` to the model matrix as covariates to use batch corrected data.

Recall we have created the factor `biology` earlier in the workshop. This factor is an interacting factor of interest between disease status and tissue regions. As such, we directly use this factor in the design matrix. 


```{r}
design <- model.matrix(~0 + biology + ruv_W1 + ruv_W2 + ruv_W3 + ruv_W4, data = colData(spe_ruv))

colnames(design)
```

To simplify the factor name, here we edit the column name of the design matrix by removing the prefix "biology".

```{r}
colnames(design) <- gsub("^biology","",colnames(design))
  
colnames(design)

```

In this analysis, we will be looking at comparison between glomerulus_abnormal and tubule_neg in DKD patient. The contrast for pairwise comparisons between different groups are set up in using the `makeContrasts` function from `Limma`.


```{r}
contr.matrix <- makeContrasts(
   DvCinGab = DKD_glomerulus_abnormal - DKD_tubule_neg,
   levels = colnames(design))
```

It is recommended to filter out genes with low coverage in the dataset to allow a more accurate mean-variance relationship and reduce the number of statistical tests. Here we use the `filterByExpr` function from the `edgeR` package to filter genes based on the model matrix, keeping as many genes as possible with resonable counts.


```{r}
keep <- filterByExpr(dge, design)
```

Here we can see that 17 genes are filtered.

```{r}
table(keep)

dge_all <- dge[keep, ]
```



## Differential expression

In the `limma-voom` pipeline, linear modelling is carried out on the log-CPM values by using the `voom`, `lmFit`, `contrasts.fit` and `eBayes` functions. In specific cases where users like to take more considerations of the log fold changes in the statistical analysis, the `treat` function is applied. 

**Notes: If there are samples are from a mixture of patients where subsets of which will have came from each patient (individual). The intra-and-inter patient correlations will need to be accounted for in the modelling. To do this, it is recommended to use the `duplicateCorrelation` function, followed by passing the resulting correlation to the `lmFit` function.**


```{r}
v <- voom(dge_all, design) 

fit <- lmFit(v)

fit_contrast <- contrasts.fit(fit, contrasts = contr.matrix)

efit <- eBayes(fit_contrast, robust = TRUE)

tfit <- treat(efit)

```


We can see that in the comparison between glomerulus_abnormal and tubule_neg in DKD patient, we found 472 up-regulated and 365 down-regulated DE genes with fold-change above 1.2 (by default).


```{r}
results_efit<- decideTests(tfit, p.value = 0.05)
summary_efit <- summary(results_efit)

summary_efit
```


### Visualisation

We can obtain the DE results by using the `TopTable` function.

```{r}
library(ggrepel)
library(tidyverse)

de_results_DvCinGab <- topTable(efit, coef = 1, sort.by = "P", n = Inf)

de_genes_toptable_DvCinGab <- topTable(efit, coef = 1, sort.by = "P", n = Inf, p.value = 0.05)

```

We can then visualise the DE genes with MA plot.

```{r fig.width=10}
de_results_DvCinGab %>% 
  mutate(DE = ifelse(logFC > 0 & adj.P.Val <0.05, "UP", 
                       ifelse(logFC <0 & adj.P.Val<0.05, "DOWN", "NOT DE"))) %>%
  ggplot(aes(AveExpr, logFC, col = DE)) + 
  geom_point(shape = 1, size = 1) + 
  geom_text_repel(data = de_genes_toptable_DvCinGab %>% 
                    mutate(DE = ifelse(logFC > 0 & adj.P.Val <0.05, "UP", 
                       ifelse(logFC <0 & adj.P.Val<0.05, "DOWN", "NOT DE"))) %>%
                    rownames_to_column(), aes(label = rowname)) +
  theme_bw() +
  xlab("Average log-expression") +
  ylab("Log-fold-change") +
  ggtitle("Abnormal glomerulus vs. Tubule neg in DKD patients (limma-voom-treat)") +
  scale_color_manual(values = c("blue","gray","red")) +
  theme(text = element_text(size=15))

```


Or Volcano plot.

```{r fig.width=10}
de_results_DvCinGab %>% 
  mutate(DE = ifelse(logFC > 0 & adj.P.Val <0.05, "UP", 
                       ifelse(logFC <0 & adj.P.Val<0.05, "DOWN", "NOT DE"))) %>%
  ggplot(aes(logFC, -log10(adj.P.Val), col = DE)) + 
  geom_point(shape = 1, size = 1) + 
  geom_text_repel(data = de_genes_toptable_DvCinGab %>% 
                    mutate(DE = ifelse(logFC > 0 & adj.P.Val <0.05, "UP", 
                       ifelse(logFC <0 & adj.P.Val<0.05, "DOWN", "NOT DE"))) %>%
                    rownames_to_column(), aes(label = rowname)) +
  theme_bw() +
  xlab("Fold change (log2)") +
  ylab("-log10(p-value)") +
  ggtitle("Abnormal glomerulus vs. Tubule neg in DKD patients (limma-voom-treat)") +
  scale_color_manual(values = c("blue","gray","red")) +
  theme(text = element_text(size=15))

```

Or we can make a interactive table using the `DT` package.

```{r}
library(DT)

updn_cols <- c(RColorBrewer::brewer.pal(6, 'Greens')[2], RColorBrewer::brewer.pal(6, 'Purples')[2])

de_genes_toptable_DvCinGab %>% 
  dplyr::select(c("logFC", "AveExpr", "P.Value", "adj.P.Val")) %>%
  DT::datatable(caption = 'Abnormal glomerulus vs. Tubule neg in DKD patients (limma-voom-treat)') %>%
  DT::formatStyle('logFC',
                valueColumns = 'logFC',
                backgroundColor = DT::styleInterval(0, rev(updn_cols))) %>%
  DT::formatSignif(1:4, digits = 4)
```

# GSEA and visualisation with vissE

For users who are interested in whether some specific genes are DE in the contrast, you can extract them from the DE tables. However, if there isn't a specific list of genes, users can proceed to perform a gene sets enrichment analysis (GSEA) to find out the enriched gene sets, which might indicate relevant or interest biological patterns.

There are many ways to perform GSEA, here we try to do GSEA with the DE genes using `fry` from the `limma` package.

We select the following gene sets to conduct gene set enrichment analysis:

* MSigDB Hallmarks - genesets from the hallmarks collection of MSigDB
* MSigDB C2 - genesets from the C2 collection of MSigDB which contains curated genesets such as those obtained from databases such as BioCarta, KEGG, PID, and Reactome, and from chemical or genetic perturbation experiments
* GO BP - biological processes from the gene ontology database
* GO MF - molecular functions from the gene ontology database
* GO CC - cellular component from the gene ontolgoy database

FDR < 0.05 indicates significantly enriched gene set.

## Load Gene sets

We load the gene sets using the `msigdb` package, and extact only the gene sets we described above. This might take a few minutes to run.

```{r}

library(msigdb)
library(GSEABase)

msigdb_hs <- getMsigdb(version = '7.2')
msigdb_hs <- appendKEGG(msigdb_hs)

sc <- listSubCollections(msigdb_hs)

gsc <- c(subsetCollection(msigdb_hs, c('h')),
  subsetCollection(msigdb_hs, 'c2', sc[grepl("^CP:",sc)]),
  subsetCollection(msigdb_hs, 'c5', sc[grepl("^GO:",sc)])) %>%
  GeneSetCollection()

```


## Enrichment analysis

Preprocessing is conducted on these genesets, filtering out genesets with less than 5 genes and creating indices vector list for formatting on the results after applying `fry`.

```{r}
fry_indices <- ids2indices(lapply(gsc, geneIds), rownames(v), remove.empty = FALSE)
names(fry_indices) <- sapply(gsc, setName)

gsc_category <- sapply(gsc, function(x) bcCategory(collectionType(x)))
gsc_category <- gsc_category[sapply(fry_indices, length) > 5]

gsc_subcategory <- sapply(gsc, function(x) bcSubCategory(collectionType(x)))
gsc_subcategory <- gsc_subcategory[sapply(fry_indices, length) > 5]

fry_indices <- fry_indices[sapply(fry_indices, length) > 5]

names(gsc_category) = names(gsc_subcategory) = names(fry_indices)

```


Now we run `fry` with all the gene sets we filtered.

```{r}

fry_indices_cat <- split(fry_indices, gsc_category[names(fry_indices)])
fry_res_out <- lapply(fry_indices_cat, function (x) {
  limma::fry(v, index = x, design = design, contrast = contr.matrix[,1], robust = TRUE)
})

post_fry_format <- function(fry_output, gsc_category, gsc_subcategory){
  names(fry_output) <- NULL
  fry_output <- do.call(rbind, fry_output)
  fry_output$GenesetName <- rownames(fry_output)
  fry_output$GenesetCat <- gsc_category[rownames(fry_output)]
  fry_output$GenesetSubCat <- gsc_subcategory[rownames(fry_output)]
  return(fry_output)
}

fry_res_sig <- post_fry_format(fry_res_out, gsc_category, gsc_subcategory) %>%
  as.data.frame() %>%
  filter(FDR < 0.05) 
```


The output is a `data.frame` object. We can either output the whole table, or inspect the top 20 gene sets in a bar plot.

We can see glomerular-related gene sets such as *glomerular_basement_membrane_development* and *glomerular_epithelial_cell_differentiation* are significantly enriched in up-regulated genes in abnormal glomerulus compared to tubule neg. Diabetic-related pathways are also found to be enriched.


```{r}
fry_res_sig %>%
  arrange(FDR) %>%
  .[seq(20),] %>%
  mutate(GenesetName = factor(GenesetName, levels = .$GenesetName)) %>%
  ggplot(aes(GenesetName, -log(FDR), fill = Direction)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  coord_flip()
```



## Visualization

An alternative way to summarise the GSEA output is to visualise common gene sets as a group.

We can use the `igraph` and `vissE` package to perform clustering on the enriched gene sets and visualise the gene sets using word cloud-based algorithm and network-based visualisation. For more information about `vissE`, check out [here](https://bioconductor.org/packages/release/bioc/html/vissE.html).

```{r}
library(vissE)
library(igraph)
dovissE <- function(fry_out, de_table, topN = 6, title = "", specific_clusters = NA){
  
  n_row = min(1000, nrow(fry_out))
  gs_sig_name <- fry_out %>% 
    filter(FDR < 0.05) %>%
    arrange(FDR) %>% 
    .[1:n_row,] %>% 
    rownames()
  gsc_sig <- gsc[gs_sig_name,]
  
  gs_ovlap <- computeMsigOverlap(gsc_sig, thresh = 0.15)
  gs_ovnet <- computeMsigNetwork(gs_ovlap, gsc)
  
  gs_stats <- -log10(fry_out[gs_sig_name,]$FDR)
  names(gs_stats) <- gs_sig_name
  
  #identify clusters
  grps = cluster_walktrap(gs_ovnet)
  #extract clustering results
  grps = groups(grps)
  #sort by cluster size
  grps = grps[order(sapply(grps, length), decreasing = TRUE)]
  
  # write output
  output_clusters <- list()
  for(i in seq(length(grps))){
    output_clusters[[i]] <- data.frame(geneset = grps[[i]], cluster = paste0("cluster",names(grps)[i]))
  }
  output_clusters <<- output_clusters %>% bind_rows()
  
  if(is.na(specific_clusters)){
    grps <- grps[1:topN]
  } else {
    grps <- grps[specific_clusters %>% as.character()]
  }
  
  #plot the top 12 clusters
  set.seed(36) #set seed for reproducible layout
  p1 <<- plotMsigNetwork(gs_ovnet, markGroups = grps, 
                        genesetStat = gs_stats, rmUnmarkedGroups = TRUE) +
    scico::scale_fill_scico(name = "-log10(FDR)")
  
  p2 <<- plotMsigWordcloud(gsc, grps, type = 'Name')
  
  genes <- unique(unlist(geneIds(gsc_sig)))
  
  genes_logfc <- de_table %>% rownames_to_column() %>% filter(rowname %in% genes) %>% .$logFC
  names(genes_logfc) <- de_table %>% rownames_to_column() %>% filter(rowname %in% genes) %>% .$rowname
  
  p3 <<- plotGeneStats(genes_logfc, gsc, grps) +
    geom_hline(yintercept = 0, colour = 2, lty = 2) +
    ylab("logFC")
  
  #p4 <- plotMsigPPI(ppi, gsc, grps[1:topN], geneStat = genes_logfc) +
  #  guides(col=guide_legend(title="logFC"))
  
  print(p2 + p1 + p3 + patchwork::plot_layout(ncol = 3) +
          patchwork::plot_annotation(title = title))  
    
}
```

A typical vissE analysis produces three plots: 

1. a word-cloud, a network and a gene statistic plot. The word-cloud plot performs a text-mining analysis to automatically annotate gene set clusters (top 9 in this case, ordered by cluster size and the -log10 of the FDR); 

2. the network plot visualises gene sets as a network where nodes are gene-sets and edges connect gene-sets that have genes in common; 

3. gene statistic plots visualise a gene-specific statistic (a log fold-change in this case) for all genes that belong to gene-sets in the cluster against the number of gene-sets that gene belongs to. 

Combined, these three plots enable users to identify higher-order biological processes, characterise these processes (word-clouds), assess the relationships between higher-order processes (network plot), and relate the experiment-specific statistics back to the identified processes (gene statistic plot), thereby providing an integrated view of the data.


```{r fig.width=15, fig.height=7}
dovissE(fry_res_sig, de_genes_toptable_DvCinGab, topN = 9, title = "Abnormal glomerulus vs. Tubule neg in DKD patients" )
```


# Summary

The analysis of the GeoMX transcriptomics data requires several steps of quality control to ensure the data is of good quality for performing downstream analyses like differential expression analysis with pipelines such as `edgeR`, `limma-voom` or `DEseq2`. The bioconductor package `standR` provides multiple functions for conducting QC and normalisation for the GeoMX DSP datasets.


# Packages used {.unnumbered}

This workflow depends on various packages from version `r BiocManager::version()` of the Bioconductor project, running on `r version$version.string` or higher. The complete list of the packages used for this workflow are shown below:

```{r session_info}
sessionInfo()
```

# Acknowledgments {.unnumbered}

We would like to thank Ahmed Mohamed and Dharmesh Bhuva for their efforts on the Bioconductor submission of the standR package.

# References {.unnumbered}
